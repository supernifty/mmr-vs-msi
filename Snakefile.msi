
# overall stats incorporating msi and mmr
#rule msi_assess:
#  input:
#    "out/mmr.summary",
#    "out/mutations.summary",
#    expand("out/{sample}.msi.{caller}.annotated.vcf", sample=config['samples'], caller=config['msi_callers'])
#  output:
#    "out/msi.summary"
#  log:
#    stderr="log/msi.summary.stderr",
#  shell:
#    "src/msi_stats.py {input} 1>{output} 2>{log.stderr}"

# summary of both mmr and msi
rule msi_mini:
  input:
    genes=config["genes_mmr"],
    summary="out/msi.summary.tsv"
  output:
    "out/msi.summary.mini.tsv"
  shell:
    "src/just_mmr.py {input.genes} < {input.summary} > {output}"

rule msi_assess_transcribed_rotated:
  input:
    mmr="out/mmr.summary",
    counts="out/mutations.summary",
    vcfs=expand("out/{tumour}.msi.{caller}.annotated.somatic.filtered.vcf", tumour=config['tumours'], caller=config['msi_callers'])
  output:
    "out/msi.summary.rotated.transcribed.tsv"
  log:
    stderr="log/msi.summary_rotated_transcribed.stderr",
  shell:
    "src/msi_stats.py --mmr {input.mmr} --counts {input.counts} --vcfs {input.vcfs} --rotate_context --transcribed_strand 1>{output} 2>{log.stderr}"

rule msi_assess_rotated:
  input:
    mmr="out/mmr.summary",
    counts="out/mutations.summary",
    vcfs=expand("out/{tumour}.msi.{caller}.annotated.somatic.filtered.vcf", tumour=config['tumours'], caller=config['msi_callers'])
  output:
    "out/msi.summary.rotated.tsv"
  log:
    stderr="log/msi.summary_rotated.stderr",
  shell:
    "src/msi_stats.py --mmr {input.mmr} --counts {input.counts} --vcfs {input.vcfs} --rotate_context 1>{output} 2>{log.stderr}"

rule msi_assess:
  input:
    mmr="out/mmr.summary",
    counts="out/mutations.summary",
    vcfs=expand("out/{tumour}.msi.{caller}.annotated.somatic.filtered.vcf", tumour=config['tumours'], caller=config['msi_callers'])
  output:
    "out/msi.summary.tsv"
  log:
    stderr="log/msi.summary.stderr",
  shell:
    "src/msi_stats.py --mmr {input.mmr} --counts {input.counts} --vcfs {input.vcfs} 1>{output} 2>{log.stderr}"

rule msi_measure_summary:
  input:
    expand("out/{tumour}.msi_measure_summary", tumour=config['tumours'])
  output:
    "out/msi.measure.summary"
  shell:
    "cat {input} > {output}"

# visualization: clustering, etc
rule msi_cluster_vis:
  input:
    "out/msi.cluster.tumours",
    "cfg/htsdb.csv"
  output:
    "out/msi.tumours.png"
  log:
    stderr="log/msi_cluster_vis.stderr",
  shell:
    "src/cluster_msi.py --image {output} --verbose --categories {input[1]} <{input[0]} 2>{log.stderr}"

rule msi_cluster_vis_range:
  input:
    "out/msi.cluster.{range}.tsv",
    "cfg/htsdb.csv"
  output:
    "out/msi.cluster.{range}.png"
  log:
    stderr="log/msi_cluster_vis_{range}.stderr",
  shell:
    "src/cluster_msi.py --image {output} --verbose --categories {input[1]} <{input[0]} 2>{log.stderr}"

rule msi_cluster_primaries:
  input:
    bed="out/regions.msi.final.exons.bed",
    categories="cfg/htsdb.csv",
    vcfs=expand("out/{tumour}.msi.{caller}.annotated.somatic.filtered.vcf", tumour=config['tumours'], caller=config['msi_callers']),
  output:
    "out/msi.primaries.cluster"
  log:
    stderr="log/msi.cluster.stderr",
  shell:
    "src/count_mutations_by_region.py --bed {input.bed} --vcf {input.vcfs} --use_lengths --categories {input.categories} --category Primary >{output} 2>{log.stderr}"

rule msi_cluster_blood:
  input:
    bed="out/regions.msi.final.exons.bed",
    categories="cfg/htsdb.csv",
    vcfs=expand("out/{sample}.msi.{caller}.annotated.vcf", sample=config['samples'], caller=config['msi_callers']),
  output:
    "out/msi.blood.cluster"
  log:
    stderr="log/msi.blood.cluster.stderr",
  shell:
    "src/count_mutations_by_region.py --verbose --bed {input.bed} --vcf {input.vcfs} --use_lengths --categories {input.categories} --category 'Whole-blood' >{output} 2>{log.stderr}"

rule msi_cluster_tumours:
  input:
    bed="out/regions.msi.final.exons.bed",
    vcfs=expand("out/{tumour}.msi.{caller}.annotated.somatic.filtered.vcf", tumour=config['tumours'], caller=config['msi_callers']),
  output:
    "out/msi.cluster.tumours"
  log:
    stderr="log/msi.cluster.stderr",
  shell:
    "src/count_mutations_by_region.py --bed {input.bed} --vcf {input.vcfs} --use_lengths >{output} 2>{log.stderr}"

rule msi_cluster_range:
  input:
    bed="out/regions.msi.final.exons.bed",
    vcfs=expand("out/{tumour}.msi.{caller}.annotated.somatic.filtered.vcf", tumour=config['tumours'], caller=config['msi_callers']),
  output:
    "out/msi.cluster.{range}.tsv"
  log:
    stderr="log/msi.cluster.{range}.stderr"
  params:
    start=lambda wildcards: wildcards.range.split(',')[0],
    finish=lambda wildcards: wildcards.range.split(',')[1]
  shell:
    "src/count_mutations_by_region.py --bed {input.bed} --vcf {input.vcfs} --use_lengths --minlength {params.start} --maxlength {params.finish} --minsamples 1 >{output} 2>{log.stderr}"

rule msi_repeat_context_vis:
  input:
    "out/msi.summary.tsv"
  output:
    "out/msi.repeat_context.all.heatmap.png"
  log:
    stderr="log/msi.repeat_context_vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --normalize_max --prefix rt_ --max_len 4 --threshold 0.1 --rotate_context < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --normalize_max --prefix rt_ --max_len 4 --threshold 0.1 --rotate_context < {input} 2>>{log.stderr}; "
    "done)"

rule msi_repeat_context_transcribed_vis:
  input:
    "out/msi.summary.rotated.transcribed.tsv"
  output:
    "out/msi.repeat_context.all.rotated.transcribed.heatmap.png"
  log:
    stderr="log/msi.repeat_context_transcribed.vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --normalize_max --prefix rt_ --max_len 4 --threshold 0.1 --rotate_context < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --normalize_max --prefix rt_ --max_len 4 --threshold 0.1 --rotate_context < {input} 2>>{log.stderr}; "
    "done)"

rule msi_repeat_context_emast_vis:
  input:
    "out/msi.summary.tsv"
  output:
    "out/msi.repeat_context_emast.all.heatmap.png"
  log:
    stderr="log/msi.repeat_context_emast_vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --normalize_max --prefix rt_ --min_len 4 --rotate_context --threshold 0.05 < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --normalize_max --prefix rt_ --min_len 4 --rotate_context --threshold 0.05 < {input} 2>>{log.stderr}; "
    "done)"

rule msi_indel_context_vis:
  input:
    "out/msi.summary.tsv"
  output:
    "out/msi.indel_context.all.heatmap.png"
  log:
    stderr="log/msi.indel_context_vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --normalize_max --prefix il_ --threshold 0.1 < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --normalize_max --prefix il_ --threshold 0.1 < {input} 2>>{log.stderr}; "
    "done)"

rule msi_repeat_indel_context_rotated_raw_vis:
  input:
    "out/msi.summary.rotated.tsv"
  output:
    "out/msi.repeat_indel_context_rotated.all.raw.heatmap.png"
  log:
    stderr="log/msi.repeat_indel_context_rotated_vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --prefix rtil_ --threshold 0.1 < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --prefix rtil_ --threshold 0.1 < {input} 2>>{log.stderr}; "
    "done)"

rule msi_repeat_indel_context_rotated_transcribed_high_threshold_vis:
  input:
    "out/msi.summary.rotated.transcribed.tsv"
  output:
    "out/msi.repeat_indel_context_rotated.all.threshold_0.3.transcribed.heatmap.png"
  log:
    stderr="log/msi.repeat_indel_context_rotated_transcribed_vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --normalize_max --prefix rtil_ --threshold 0.3 < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --normalize_max --prefix rtil_ --threshold 0.3 < {input} 2>>{log.stderr}; "
    "done)"

rule msi_repeat_indel_context_rotated_high_threshold_vis:
  input:
    "out/msi.summary.rotated.tsv"
  output:
    "out/msi.repeat_indel_context_rotated.all.threshold_0.3.heatmap.png"
  log:
    stderr="log/msi.repeat_indel_context_rotated_vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --normalize_max --prefix rtil_ --threshold 0.3 < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --normalize_max --prefix rtil_ --threshold 0.3 < {input} 2>>{log.stderr}; "
    "done)"

rule msi_repeat_indel_context_rotated_log_vis:
  input:
    "out/msi.summary.rotated.tsv"
  output:
    "out/msi.repeat_indel_context_rotated.all.threshold_0.3.log.heatmap.png"
  log:
    stderr="log/msi.repeat_indel_context_rotated_vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --normalize_max --prefix rtil_ --threshold 0.3 --log < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --normalize_max --prefix rtil_ --threshold 0.3 --log < {input} 2>>{log.stderr}; "
    "done)"

rule msi_repeat_indel_context_rotated_vis:
  input:
    "out/msi.summary.rotated.tsv"
  output:
    "out/msi.repeat_indel_context_rotated.all.heatmap.png"
  log:
    stderr="log/msi.repeat_indel_context_rotated_vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --normalize_max --prefix rtil_ --threshold 0.1 < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --normalize_max --prefix rtil_ --threshold 0.1 < {input} 2>>{log.stderr}; "
    "done)"

rule msi_repeat_indel_context_vis:
  input:
    "out/msi.summary"
  output:
    "out/msi.repeat_indel_context.all.heatmap.png"
  log:
    stderr="log/msi.repeat_indel_context_vis.stderr"
  shell:
    "src/context_heatmap.py --verbose --image {output} --normalize_max --prefix rtil_ --threshold 0.1 < {input} 2>{log.stderr} && "
    "(IFS=$(echo -en \"\\n\\b\") && for category in $(cut -f3 {input} | sort -u | grep -v Type); do "
    "image=\"{output}\"; "
    "image=${{image/all/$category}}; "
    "src/context_heatmap.py --verbose --category \"$category\" --image \"$image\" --normalize_max --prefix rtil_ --threshold 0.1 < {input} 2>>{log.stderr}; "
    "done)"

# tumour specific analysis
# note that we use the vcf before germline has been subtracted out
rule msi_measure:
  input:
    regions="out/regions.msi.final.exons.bed", # exons only for now
    vcfs=expand("out/{{tumour}}.msi.{caller}.annotated.vcf", caller=config['msi_callers']), # multiple callers are currently combined (concatenated)
    metadata="cfg/sample-metadata.csv"
  output:
    detail="out/{tumour}.msi_measure_detail",
    summary="out/{tumour}.msi_measure_summary"
  log:
    stderr="log/msi_measure.{tumour}.stderr",
  shell:
    #"src/msi_measure.sh {input} {output[1]} >{output[0]} 2>{log.stderr}"
    "src/msi_measure.py --metadata {input.metadata} --verbose --regions {input.regions} --tumours {input.vcfs} --summary {output.summary} >{output.detail} 2>{log.stderr}"

# tumour specific - remove germline calls
rule filter_somatic_msi:
  input:
    "out/{tumour}.msi.{caller}.annotated.vcf",
    expand("out/{sample}.msi.{{caller}}.annotated.vcf", sample=config['samples']) # we depend on the germline which is one of the other samples
  output:
    "out/{tumour}.msi.{caller}.annotated.somatic.vcf"
  log:
    stderr="log/filter_somatic_msi.{tumour}.{caller}.stderr"
  shell:
    "src/subtract_germline.sh {input[0]} >{output} 2>{log.stderr}"

rule filter_somatic_msi_qual:
  input:
    vcf="out/{tumour}.msi.{caller}.annotated.somatic.vcf"
  output:
    "out/{tumour}.msi.{caller}.annotated.somatic.filtered.vcf"
  log:
    stderr="log/{tumour}.{caller}.filter_somatic_msi_qual.stderr"
  params:
    qual=config['msi_qual'],
  shell:
    "src/filter_vcf_qual.py --qual {params.qual} < {input.vcf} > {output} 2>{log.stderr}"

rule msi_regions_exons:
  input:
    "out/regions.msi.final.bed",
  output:
    "out/regions.msi.final.exons.bed",
  shell:
    "grep exon < {input} > {output}"

# find common somatic calls for each caller
rule common_msi_mutations:
  input:
    expand("out/{tumour}.msi.{{caller}}.annotated.somatic.filtered.vcf", tumour=config['tumours'])
  output:
    "out/msi.{caller}.common"
  shell:
    "python src/find_common_mutations.py --vcfs {input} --threshold 2 --position_only > {output}"

# annotates vcf files with vep
#rule msi_vep:
#  input:
#    "out/regions.msi.final.bed",
#    "out/{sample}.msi.{caller}.annotated.vcf"
#  output:
#    "out/{sample}.msi.{caller}.annotated.vep.vcf",
#  log:
#    stderr="log/msi.vep.{sample}.{caller}.stderr",
#    stdout="log/msi.vep.{sample}.{caller}.stdout"
#  shell:
#    "src/annotate.sh {config[genome]} {input} {output} 1>{log.stdout} 2>{log.stderr}"

rule msi_cluster_samples_vis:
  input:
    "out/msi.samples.cluster",
    "cfg/htsdb.csv"
  output:
    "out/msi.samples.png"
  log:
    stderr="log/msi_samples_cluster_vis.stderr",
  shell:
    "src/cluster_msi.py --image {output} --verbose --categories {input[1]} <{input[0]} 2>{log.stderr}"


# cluster msi on all samples (not just tumour)
rule msi_cluster_samples:
  input:
    bed="out/regions.msi.final.exons.bed",
    categories="cfg/htsdb.csv",
    vcfs=expand("out/{sample}.msi.{caller}.annotated.vcf", sample=config['samples'], caller=config['msi_callers']),
  output:
    "out/msi.samples.cluster"
  log:
    stderr="log/msi.cluster.samples.stderr",
  shell:
    "src/count_mutations_by_region.py --bed {input.bed} --vcf {input.vcfs} --use_lengths --categories {input.categories} >{output} 2>{log.stderr}"


# msi output is list of samples and the degree of MSI found
rule annotate_msi:
  input:
    "out/regions.msi.final.bed",
    "in/{sample}.{caller}.vcf" # each unfiltered msi_caller
  output:
    "out/{sample}.msi.{caller}.annotated.vcf" # makes a filtered vcf
  log:
    stderr="log/msi_filter.{sample}.{caller}.stderr",
  shell:
    "src/annotate_vcf.py {input[0]} < {input[1]} 1>{output} 2>{log.stderr}"

# add oncogene annotations to msi list
rule annotate_msi_all_oncogene_regions:
  input:
    "out/regions.msi.oncogenes.bed", # list of msi regions
    "out/regions.oncogenes.all.bed", # list of oncogene regions 
    "cfg/msi.seltarbase.bed", # list of seltarbase regions 
  output:
    "out/regions.msi.final.bed" # annotated regions
  log:
    stderr="log/annotate_bed.stderr",
  shell:
    "src/annotate_bed.py all_oncogene {input[1]} < {input[0]} | src/annotate_bed.py seltarbase {input[2]} > {output} 2> {log.stderr}"

# add oncogene annotations to msi list
rule annotate_msi_oncogene_regions:
  input:
    "out/regions.oncogenes.bed", # list of oncogene regions 
    "out/regions.msi.bed", # list of msi regions
  output:
    "out/regions.msi.oncogenes.bed" # annotated regions
  log:
    stderr="log/annotate_bed.stderr",
  shell:
    "src/annotate_bed.py oncogene {input[0]} < {input[1]} > {output} 2> {log.stderr}"

# add oncogene annotations to msi list
rule make_all_oncogene_regions:
  input:
    "out/oncogenes.all.msi", # list of genes 
    config["refseq"], # list of refseq regions
  output:
    "out/regions.oncogenes.all.bed" # oncogene regions
  shell:
    "module load bedtools-intel/2.27.1; "
    "src/make_bed.py {input[0]} < {input[1]} | sort -k1,1 -k2,2n > {output}" 


# add oncogene annotations to msi list
rule make_oncogene_regions:
  input:
    "out/oncogenes.msi", # list of genes 
    config["refseq"], # list of refseq regions
  output:
    "out/regions.oncogenes.bed" # oncogene regions
  shell:
    "module load bedtools-intel/2.27.1; "
    "src/make_bed.py {input[0]} < {input[1]} | sort -k1,1 -k2,2n > {output}" 

# make a list of genes relevant to msi for the cancer being studied
rule make_all_oncogenes:
  input:
    config['cosmic']
  output:
    "out/oncogenes.all.msi"
  shell:
    "cut -f1 < {input} | sort > {output}"

# make a list of genes relevant to msi for the cancer being studied
rule make_msi_oncogenes:
  input:
    config['cosmic']
  output:
    "out/oncogenes.msi"
  shell:
    "cut -f1,8,9,10,11 < {input} | grep -i {config[cancer_type]} | cut -f1 | sort > {output}"

# basic msi stats
rule bed_stats:
  input:
    "out/regions.msi.bed"
  output:
    "out/regions.msi.stats"
  log:
    stderr="log/bed_stats.log"
  shell:
    "src/bed_stats.py <{input} 1>{output} 2>{log.stderr}"

# limits msi regions by length and repeat type
rule make_msi_regions:
  input:
    "reference/msi.candidates.bed"
  output:
    "out/regions.msi.bed"
  log:
    stderr="log/make_msi_regions.stderr",
  shell:
    "src/filter_msi.py --exons_only --minlen 8 --maxlen 100000 --minrepeat 1 --maxrepeat 4 < {input} 1>{output} 2>{log.stderr}"


